; NOTE: Assertions have been autogenerated by test/update_tpde_llc_test_checks.py UTC_ARGS: --version 5
; SPDX-FileCopyrightText: 2025 Contributors to TPDE <https://tpde.org>
;
; SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception

; RUN: tpde-llc --target=x86_64 %s | %objdump | FileCheck %s -check-prefixes=X64
; RUN: tpde-llc --target=aarch64 %s | %objdump | FileCheck %s -check-prefixes=ARM64

; TODO(ts): datalayout depending on arch?
; target datalayout = "e-m:e-i8:8:32-i16:16:32-i64:64-i128:128-n32:64-S128"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"


define i8 @load_i8(ptr %a) {
; X64-LABEL: <load_i8>:
; X64:         push rbp
; X64-NEXT:    mov rbp, rsp
; X64-NEXT:    nop word ptr [rax + rax]
; X64-NEXT:    sub rsp, 0x30
; X64-NEXT:    movzx edi, byte ptr [rdi]
; X64-NEXT:    mov eax, edi
; X64-NEXT:    add rsp, 0x30
; X64-NEXT:    pop rbp
; X64-NEXT:    ret
;
; ARM64-LABEL: <load_i8>:
; ARM64:         sub sp, sp, #0xa0
; ARM64-NEXT:    stp x29, x30, [sp]
; ARM64-NEXT:    mov x29, sp
; ARM64-NEXT:    nop
; ARM64-NEXT:    ldrb w0, [x0]
; ARM64-NEXT:    ldp x29, x30, [sp]
; ARM64-NEXT:    add sp, sp, #0xa0
; ARM64-NEXT:    ret
entry:
  %b = load i8, ptr %a, align 1
  ret i8 %b
}

define i8 @load_i8_alt(ptr %a) {
; X64-LABEL: <load_i8_alt>:
; X64:         push rbp
; X64-NEXT:    mov rbp, rsp
; X64-NEXT:    nop word ptr [rax + rax]
; X64-NEXT:    sub rsp, 0x30
; X64-NEXT:    movzx eax, byte ptr [rdi]
; X64-NEXT:    movzx edi, byte ptr [rdi]
; X64-NEXT:    mov eax, edi
; X64-NEXT:    add rsp, 0x30
; X64-NEXT:    pop rbp
; X64-NEXT:    ret
;
; ARM64-LABEL: <load_i8_alt>:
; ARM64:         sub sp, sp, #0xa0
; ARM64-NEXT:    stp x29, x30, [sp]
; ARM64-NEXT:    mov x29, sp
; ARM64-NEXT:    nop
; ARM64-NEXT:    ldrb w1, [x0]
; ARM64-NEXT:    ldrb w0, [x0]
; ARM64-NEXT:    ldp x29, x30, [sp]
; ARM64-NEXT:    add sp, sp, #0xa0
; ARM64-NEXT:    ret
entry:
  %b = load i8, ptr %a, align 1
  %c = load i8, ptr %a, align 1
  ret i8 %c
}


define i16 @load_i16(ptr %a) {
; X64-LABEL: <load_i16>:
; X64:         push rbp
; X64-NEXT:    mov rbp, rsp
; X64-NEXT:    nop word ptr [rax + rax]
; X64-NEXT:    sub rsp, 0x30
; X64-NEXT:    movzx edi, word ptr [rdi]
; X64-NEXT:    mov eax, edi
; X64-NEXT:    add rsp, 0x30
; X64-NEXT:    pop rbp
; X64-NEXT:    ret
;
; ARM64-LABEL: <load_i16>:
; ARM64:         sub sp, sp, #0xa0
; ARM64-NEXT:    stp x29, x30, [sp]
; ARM64-NEXT:    mov x29, sp
; ARM64-NEXT:    nop
; ARM64-NEXT:    ldrh w0, [x0]
; ARM64-NEXT:    ldp x29, x30, [sp]
; ARM64-NEXT:    add sp, sp, #0xa0
; ARM64-NEXT:    ret
entry:
  %b = load i16, ptr %a, align 2
  ret i16 %b
}

define i16 @load_i16_alt(ptr %a) {
; X64-LABEL: <load_i16_alt>:
; X64:         push rbp
; X64-NEXT:    mov rbp, rsp
; X64-NEXT:    nop word ptr [rax + rax]
; X64-NEXT:    sub rsp, 0x30
; X64-NEXT:    movzx eax, word ptr [rdi]
; X64-NEXT:    movzx edi, word ptr [rdi]
; X64-NEXT:    mov eax, edi
; X64-NEXT:    add rsp, 0x30
; X64-NEXT:    pop rbp
; X64-NEXT:    ret
;
; ARM64-LABEL: <load_i16_alt>:
; ARM64:         sub sp, sp, #0xa0
; ARM64-NEXT:    stp x29, x30, [sp]
; ARM64-NEXT:    mov x29, sp
; ARM64-NEXT:    nop
; ARM64-NEXT:    ldrh w1, [x0]
; ARM64-NEXT:    ldrh w0, [x0]
; ARM64-NEXT:    ldp x29, x30, [sp]
; ARM64-NEXT:    add sp, sp, #0xa0
; ARM64-NEXT:    ret
entry:
  %b = load i16, ptr %a, align 2
  %c = load i16, ptr %a, align 2
  ret i16 %c
}


define i24 @load_i24(ptr %a) {
; X64-LABEL: <load_i24>:
; X64:         push rbp
; X64-NEXT:    mov rbp, rsp
; X64-NEXT:    nop word ptr [rax + rax]
; X64-NEXT:    sub rsp, 0x30
; X64-NEXT:    movzx eax, word ptr [rdi]
; X64-NEXT:    movzx edi, byte ptr [rdi + 0x2]
; X64-NEXT:    shl edi, 0x10
; X64-NEXT:    or edi, eax
; X64-NEXT:    mov eax, edi
; X64-NEXT:    add rsp, 0x30
; X64-NEXT:    pop rbp
; X64-NEXT:    ret
;
; ARM64-LABEL: <load_i24>:
; ARM64:         sub sp, sp, #0xa0
; ARM64-NEXT:    stp x29, x30, [sp]
; ARM64-NEXT:    mov x29, sp
; ARM64-NEXT:    nop
; ARM64-NEXT:    ldrb w1, [x0, #0x2]
; ARM64-NEXT:    ldrh w0, [x0]
; ARM64-NEXT:    orr w2, w0, w1, lsl #16
; ARM64-NEXT:    mov w0, w2
; ARM64-NEXT:    ldp x29, x30, [sp]
; ARM64-NEXT:    add sp, sp, #0xa0
; ARM64-NEXT:    ret
entry:
  %b = load i24, ptr %a, align 2
  ret i24 %b
}

define i24 @load_i24_alloca() {
; X64-LABEL: <load_i24_alloca>:
; X64:         push rbp
; X64-NEXT:    mov rbp, rsp
; X64-NEXT:    nop word ptr [rax + rax]
; X64-NEXT:    sub rsp, 0x30
; X64-NEXT:    movzx eax, word ptr [rbp - 0x2c]
; X64-NEXT:    movzx ecx, byte ptr [rbp - 0x2a]
; X64-NEXT:    shl ecx, 0x10
; X64-NEXT:    or ecx, eax
; X64-NEXT:    mov eax, ecx
; X64-NEXT:    add rsp, 0x30
; X64-NEXT:    pop rbp
; X64-NEXT:    ret
;
; ARM64-LABEL: <load_i24_alloca>:
; ARM64:         sub sp, sp, #0xb0
; ARM64-NEXT:    stp x29, x30, [sp]
; ARM64-NEXT:    mov x29, sp
; ARM64-NEXT:    nop
; ARM64-NEXT:    ldrb w0, [x29, #0xa2]
; ARM64-NEXT:    ldrh w1, [x29, #0xa0]
; ARM64-NEXT:    orr w2, w1, w0, lsl #16
; ARM64-NEXT:    mov w0, w2
; ARM64-NEXT:    ldp x29, x30, [sp]
; ARM64-NEXT:    add sp, sp, #0xb0
; ARM64-NEXT:    ret
entry:
   %0 = alloca i24
   %1 = load i24, ptr %0
   ret i24 %1
}

define i24 @load_i24_alt(ptr %a) {
; X64-LABEL: <load_i24_alt>:
; X64:         push rbp
; X64-NEXT:    mov rbp, rsp
; X64-NEXT:    nop word ptr [rax + rax]
; X64-NEXT:    sub rsp, 0x30
; X64-NEXT:    movzx eax, word ptr [rdi]
; X64-NEXT:    movzx ecx, byte ptr [rdi + 0x2]
; X64-NEXT:    shl ecx, 0x10
; X64-NEXT:    or ecx, eax
; X64-NEXT:    movzx eax, word ptr [rdi]
; X64-NEXT:    movzx edi, byte ptr [rdi + 0x2]
; X64-NEXT:    shl edi, 0x10
; X64-NEXT:    or edi, eax
; X64-NEXT:    mov eax, edi
; X64-NEXT:    add rsp, 0x30
; X64-NEXT:    pop rbp
; X64-NEXT:    ret
;
; ARM64-LABEL: <load_i24_alt>:
; ARM64:         sub sp, sp, #0xa0
; ARM64-NEXT:    stp x29, x30, [sp]
; ARM64-NEXT:    mov x29, sp
; ARM64-NEXT:    nop
; ARM64-NEXT:    ldrb w1, [x0, #0x2]
; ARM64-NEXT:    ldrh w2, [x0]
; ARM64-NEXT:    orr w3, w2, w1, lsl #16
; ARM64-NEXT:    ldrb w1, [x0, #0x2]
; ARM64-NEXT:    ldrh w0, [x0]
; ARM64-NEXT:    orr w2, w0, w1, lsl #16
; ARM64-NEXT:    mov w0, w2
; ARM64-NEXT:    ldp x29, x30, [sp]
; ARM64-NEXT:    add sp, sp, #0xa0
; ARM64-NEXT:    ret
entry:
  %b = load i24, ptr %a, align 2
  %c = load i24, ptr %a, align 2
  ret i24 %c
}


define i32 @load_i32(ptr %a) {
; X64-LABEL: <load_i32>:
; X64:         push rbp
; X64-NEXT:    mov rbp, rsp
; X64-NEXT:    nop word ptr [rax + rax]
; X64-NEXT:    sub rsp, 0x30
; X64-NEXT:    mov edi, dword ptr [rdi]
; X64-NEXT:    mov eax, edi
; X64-NEXT:    add rsp, 0x30
; X64-NEXT:    pop rbp
; X64-NEXT:    ret
;
; ARM64-LABEL: <load_i32>:
; ARM64:         sub sp, sp, #0xa0
; ARM64-NEXT:    stp x29, x30, [sp]
; ARM64-NEXT:    mov x29, sp
; ARM64-NEXT:    nop
; ARM64-NEXT:    ldr w0, [x0]
; ARM64-NEXT:    ldp x29, x30, [sp]
; ARM64-NEXT:    add sp, sp, #0xa0
; ARM64-NEXT:    ret
entry:
  %b = load i32, ptr %a, align 4
  ret i32 %b
}

define i32 @load_i32_alloca() {
; X64-LABEL: <load_i32_alloca>:
; X64:         push rbp
; X64-NEXT:    mov rbp, rsp
; X64-NEXT:    nop word ptr [rax + rax]
; X64-NEXT:    sub rsp, 0x30
; X64-NEXT:    mov eax, dword ptr [rbp - 0x2c]
; X64-NEXT:    add rsp, 0x30
; X64-NEXT:    pop rbp
; X64-NEXT:    ret
;
; ARM64-LABEL: <load_i32_alloca>:
; ARM64:         sub sp, sp, #0xb0
; ARM64-NEXT:    stp x29, x30, [sp]
; ARM64-NEXT:    mov x29, sp
; ARM64-NEXT:    nop
; ARM64-NEXT:    ldr w0, [x29, #0xa0]
; ARM64-NEXT:    ldp x29, x30, [sp]
; ARM64-NEXT:    add sp, sp, #0xb0
; ARM64-NEXT:    ret
entry:
   %0 = alloca i32
   %1 = load i32, ptr %0
   ret i32 %1
}

define i32 @load_i32_alt(ptr %a) {
; X64-LABEL: <load_i32_alt>:
; X64:         push rbp
; X64-NEXT:    mov rbp, rsp
; X64-NEXT:    nop word ptr [rax + rax]
; X64-NEXT:    sub rsp, 0x30
; X64-NEXT:    mov eax, dword ptr [rdi]
; X64-NEXT:    mov edi, dword ptr [rdi]
; X64-NEXT:    mov eax, edi
; X64-NEXT:    add rsp, 0x30
; X64-NEXT:    pop rbp
; X64-NEXT:    ret
;
; ARM64-LABEL: <load_i32_alt>:
; ARM64:         sub sp, sp, #0xa0
; ARM64-NEXT:    stp x29, x30, [sp]
; ARM64-NEXT:    mov x29, sp
; ARM64-NEXT:    nop
; ARM64-NEXT:    ldr w1, [x0]
; ARM64-NEXT:    ldr w0, [x0]
; ARM64-NEXT:    ldp x29, x30, [sp]
; ARM64-NEXT:    add sp, sp, #0xa0
; ARM64-NEXT:    ret
entry:
  %b = load i32, ptr %a, align 4
  %c = load i32, ptr %a, align 4
  ret i32 %c
}

define i32 @load_i32_grep(ptr %a) {
; X64-LABEL: <load_i32_grep>:
; X64:         push rbp
; X64-NEXT:    mov rbp, rsp
; X64-NEXT:    nop word ptr [rax + rax]
; X64-NEXT:    sub rsp, 0x30
; X64-NEXT:    lea rdi, [rdi + 0x10]
; X64-NEXT:    mov eax, dword ptr [rdi]
; X64-NEXT:    mov edi, dword ptr [rdi]
; X64-NEXT:    add rsp, 0x30
; X64-NEXT:    pop rbp
; X64-NEXT:    ret
;
; ARM64-LABEL: <load_i32_grep>:
; ARM64:         sub sp, sp, #0xa0
; ARM64-NEXT:    stp x29, x30, [sp]
; ARM64-NEXT:    mov x29, sp
; ARM64-NEXT:    nop
; ARM64-NEXT:    add x0, x0, #0x10
; ARM64-NEXT:    ldr w1, [x0]
; ARM64-NEXT:    ldr w0, [x0]
; ARM64-NEXT:    mov w0, w1
; ARM64-NEXT:    ldp x29, x30, [sp]
; ARM64-NEXT:    add sp, sp, #0xa0
; ARM64-NEXT:    ret
entry:
  %gep = getelementptr i32, ptr %a, i64 4
  %load = load i32, ptr %gep, align 4
  %load2 = load i32, ptr %gep, align 4
  ret i32 %load
}


define i40 @load_i40(ptr %a) {
; X64-LABEL: <load_i40>:
; X64:         push rbp
; X64-NEXT:    mov rbp, rsp
; X64-NEXT:    nop word ptr [rax + rax]
; X64-NEXT:    sub rsp, 0x30
; X64-NEXT:    mov eax, dword ptr [rdi]
; X64-NEXT:    movzx edi, byte ptr [rdi + 0x4]
; X64-NEXT:    shl rdi, 0x20
; X64-NEXT:    or rdi, rax
; X64-NEXT:    mov rax, rdi
; X64-NEXT:    add rsp, 0x30
; X64-NEXT:    pop rbp
; X64-NEXT:    ret
;
; ARM64-LABEL: <load_i40>:
; ARM64:         sub sp, sp, #0xa0
; ARM64-NEXT:    stp x29, x30, [sp]
; ARM64-NEXT:    mov x29, sp
; ARM64-NEXT:    nop
; ARM64-NEXT:    ldrb w1, [x0, #0x4]
; ARM64-NEXT:    ldr w0, [x0]
; ARM64-NEXT:    orr x2, x0, x1, lsl #32
; ARM64-NEXT:    mov x0, x2
; ARM64-NEXT:    ldp x29, x30, [sp]
; ARM64-NEXT:    add sp, sp, #0xa0
; ARM64-NEXT:    ret
entry:
  %b = load i40, ptr %a, align 2
  ret i40 %b
}

define i40 @load_i40_alt(ptr %a) {
; X64-LABEL: <load_i40_alt>:
; X64:         push rbp
; X64-NEXT:    mov rbp, rsp
; X64-NEXT:    nop word ptr [rax + rax]
; X64-NEXT:    sub rsp, 0x30
; X64-NEXT:    mov eax, dword ptr [rdi]
; X64-NEXT:    movzx ecx, byte ptr [rdi + 0x4]
; X64-NEXT:    shl rcx, 0x20
; X64-NEXT:    or rcx, rax
; X64-NEXT:    mov eax, dword ptr [rdi]
; X64-NEXT:    movzx edi, byte ptr [rdi + 0x4]
; X64-NEXT:    shl rdi, 0x20
; X64-NEXT:    or rdi, rax
; X64-NEXT:    mov rax, rdi
; X64-NEXT:    add rsp, 0x30
; X64-NEXT:    pop rbp
; X64-NEXT:    ret
;
; ARM64-LABEL: <load_i40_alt>:
; ARM64:         sub sp, sp, #0xa0
; ARM64-NEXT:    stp x29, x30, [sp]
; ARM64-NEXT:    mov x29, sp
; ARM64-NEXT:    nop
; ARM64-NEXT:    ldrb w1, [x0, #0x4]
; ARM64-NEXT:    ldr w2, [x0]
; ARM64-NEXT:    orr x3, x2, x1, lsl #32
; ARM64-NEXT:    ldrb w1, [x0, #0x4]
; ARM64-NEXT:    ldr w0, [x0]
; ARM64-NEXT:    orr x2, x0, x1, lsl #32
; ARM64-NEXT:    mov x0, x2
; ARM64-NEXT:    ldp x29, x30, [sp]
; ARM64-NEXT:    add sp, sp, #0xa0
; ARM64-NEXT:    ret
entry:
  %b = load i40, ptr %a, align 2
  %c = load i40, ptr %a, align 2
  ret i40 %c
}


define i48 @load_i48(ptr %a) {
; X64-LABEL: <load_i48>:
; X64:         push rbp
; X64-NEXT:    mov rbp, rsp
; X64-NEXT:    nop word ptr [rax + rax]
; X64-NEXT:    sub rsp, 0x30
; X64-NEXT:    mov eax, dword ptr [rdi]
; X64-NEXT:    movzx edi, word ptr [rdi + 0x4]
; X64-NEXT:    shl rdi, 0x20
; X64-NEXT:    or rdi, rax
; X64-NEXT:    mov rax, rdi
; X64-NEXT:    add rsp, 0x30
; X64-NEXT:    pop rbp
; X64-NEXT:    ret
;
; ARM64-LABEL: <load_i48>:
; ARM64:         sub sp, sp, #0xa0
; ARM64-NEXT:    stp x29, x30, [sp]
; ARM64-NEXT:    mov x29, sp
; ARM64-NEXT:    nop
; ARM64-NEXT:    ldrh w1, [x0, #0x4]
; ARM64-NEXT:    ldr w0, [x0]
; ARM64-NEXT:    orr x2, x0, x1, lsl #32
; ARM64-NEXT:    mov x0, x2
; ARM64-NEXT:    ldp x29, x30, [sp]
; ARM64-NEXT:    add sp, sp, #0xa0
; ARM64-NEXT:    ret
entry:
  %b = load i48, ptr %a, align 2
  ret i48 %b
}

define i48 @load_i48_alt(ptr %a) {
; X64-LABEL: <load_i48_alt>:
; X64:         push rbp
; X64-NEXT:    mov rbp, rsp
; X64-NEXT:    nop word ptr [rax + rax]
; X64-NEXT:    sub rsp, 0x30
; X64-NEXT:    mov eax, dword ptr [rdi]
; X64-NEXT:    movzx ecx, word ptr [rdi + 0x4]
; X64-NEXT:    shl rcx, 0x20
; X64-NEXT:    or rcx, rax
; X64-NEXT:    mov eax, dword ptr [rdi]
; X64-NEXT:    movzx edi, word ptr [rdi + 0x4]
; X64-NEXT:    shl rdi, 0x20
; X64-NEXT:    or rdi, rax
; X64-NEXT:    mov rax, rdi
; X64-NEXT:    add rsp, 0x30
; X64-NEXT:    pop rbp
; X64-NEXT:    ret
;
; ARM64-LABEL: <load_i48_alt>:
; ARM64:         sub sp, sp, #0xa0
; ARM64-NEXT:    stp x29, x30, [sp]
; ARM64-NEXT:    mov x29, sp
; ARM64-NEXT:    nop
; ARM64-NEXT:    ldrh w1, [x0, #0x4]
; ARM64-NEXT:    ldr w2, [x0]
; ARM64-NEXT:    orr x3, x2, x1, lsl #32
; ARM64-NEXT:    ldrh w1, [x0, #0x4]
; ARM64-NEXT:    ldr w0, [x0]
; ARM64-NEXT:    orr x2, x0, x1, lsl #32
; ARM64-NEXT:    mov x0, x2
; ARM64-NEXT:    ldp x29, x30, [sp]
; ARM64-NEXT:    add sp, sp, #0xa0
; ARM64-NEXT:    ret
entry:
  %b = load i48, ptr %a, align 2
  %c = load i48, ptr %a, align 2
  ret i48 %c
}


define i56 @load_i56(ptr %a) {
; X64-LABEL: <load_i56>:
; X64:         push rbp
; X64-NEXT:    mov rbp, rsp
; X64-NEXT:    nop word ptr [rax + rax]
; X64-NEXT:    sub rsp, 0x30
; X64-NEXT:    movzx eax, word ptr [rdi + 0x4]
; X64-NEXT:    movzx ecx, byte ptr [rdi + 0x6]
; X64-NEXT:    shl ecx, 0x10
; X64-NEXT:    or ecx, eax
; X64-NEXT:    shl rcx, 0x20
; X64-NEXT:    mov eax, dword ptr [rdi]
; X64-NEXT:    or rax, rcx
; X64-NEXT:    add rsp, 0x30
; X64-NEXT:    pop rbp
; X64-NEXT:    ret
;
; ARM64-LABEL: <load_i56>:
; ARM64:         sub sp, sp, #0xa0
; ARM64-NEXT:    stp x29, x30, [sp]
; ARM64-NEXT:    mov x29, sp
; ARM64-NEXT:    nop
; ARM64-NEXT:    ldrb w1, [x0, #0x6]
; ARM64-NEXT:    ldrh w2, [x0, #0x4]
; ARM64-NEXT:    orr w1, w2, w1, lsl #16
; ARM64-NEXT:    ldr w2, [x0]
; ARM64-NEXT:    orr x0, x2, x1, lsl #32
; ARM64-NEXT:    ldp x29, x30, [sp]
; ARM64-NEXT:    add sp, sp, #0xa0
; ARM64-NEXT:    ret
entry:
  %b = load i56, ptr %a, align 2
  ret i56 %b
}

define i56 @load_i56_alloca() {
; X64-LABEL: <load_i56_alloca>:
; X64:         push rbp
; X64-NEXT:    mov rbp, rsp
; X64-NEXT:    nop word ptr [rax + rax]
; X64-NEXT:    sub rsp, 0x30
; X64-NEXT:    movzx eax, word ptr [rbp - 0x2c]
; X64-NEXT:    movzx ecx, byte ptr [rbp - 0x2a]
; X64-NEXT:    shl ecx, 0x10
; X64-NEXT:    or ecx, eax
; X64-NEXT:    shl rcx, 0x20
; X64-NEXT:    mov eax, dword ptr [rbp - 0x30]
; X64-NEXT:    or rax, rcx
; X64-NEXT:    add rsp, 0x30
; X64-NEXT:    pop rbp
; X64-NEXT:    ret
;
; ARM64-LABEL: <load_i56_alloca>:
; ARM64:         sub sp, sp, #0xb0
; ARM64-NEXT:    stp x29, x30, [sp]
; ARM64-NEXT:    mov x29, sp
; ARM64-NEXT:    nop
; ARM64-NEXT:    ldrb w0, [x29, #0xa6]
; ARM64-NEXT:    ldrh w1, [x29, #0xa4]
; ARM64-NEXT:    orr w0, w1, w0, lsl #16
; ARM64-NEXT:    ldr w1, [x29, #0xa0]
; ARM64-NEXT:    orr x2, x1, x0, lsl #32
; ARM64-NEXT:    mov x0, x2
; ARM64-NEXT:    ldp x29, x30, [sp]
; ARM64-NEXT:    add sp, sp, #0xb0
; ARM64-NEXT:    ret
entry:
   %0 = alloca i56
   %1 = load i56, ptr %0
   ret i56 %1
}

define i56 @load_i56_alt(ptr %a) {
; X64-LABEL: <load_i56_alt>:
; X64:         push rbp
; X64-NEXT:    mov rbp, rsp
; X64-NEXT:    nop word ptr [rax + rax]
; X64-NEXT:    sub rsp, 0x30
; X64-NEXT:    movzx eax, word ptr [rdi + 0x4]
; X64-NEXT:    movzx ecx, byte ptr [rdi + 0x6]
; X64-NEXT:    shl ecx, 0x10
; X64-NEXT:    or ecx, eax
; X64-NEXT:    shl rcx, 0x20
; X64-NEXT:    mov eax, dword ptr [rdi]
; X64-NEXT:    or rax, rcx
; X64-NEXT:    movzx eax, word ptr [rdi + 0x4]
; X64-NEXT:    movzx ecx, byte ptr [rdi + 0x6]
; X64-NEXT:    shl ecx, 0x10
; X64-NEXT:    or ecx, eax
; X64-NEXT:    shl rcx, 0x20
; X64-NEXT:    mov eax, dword ptr [rdi]
; X64-NEXT:    or rax, rcx
; X64-NEXT:    add rsp, 0x30
; X64-NEXT:    pop rbp
; X64-NEXT:    ret
;
; ARM64-LABEL: <load_i56_alt>:
; ARM64:         sub sp, sp, #0xa0
; ARM64-NEXT:    stp x29, x30, [sp]
; ARM64-NEXT:    mov x29, sp
; ARM64-NEXT:    nop
; ARM64-NEXT:    ldrb w1, [x0, #0x6]
; ARM64-NEXT:    ldrh w2, [x0, #0x4]
; ARM64-NEXT:    orr w1, w2, w1, lsl #16
; ARM64-NEXT:    ldr w2, [x0]
; ARM64-NEXT:    orr x3, x2, x1, lsl #32
; ARM64-NEXT:    ldrb w1, [x0, #0x6]
; ARM64-NEXT:    ldrh w2, [x0, #0x4]
; ARM64-NEXT:    orr w1, w2, w1, lsl #16
; ARM64-NEXT:    ldr w2, [x0]
; ARM64-NEXT:    orr x0, x2, x1, lsl #32
; ARM64-NEXT:    ldp x29, x30, [sp]
; ARM64-NEXT:    add sp, sp, #0xa0
; ARM64-NEXT:    ret
entry:
  %b = load i56, ptr %a, align 2
  %c = load i56, ptr %a, align 2
  ret i56 %c
}


define i64 @load_i64(ptr %a) {
; X64-LABEL: <load_i64>:
; X64:         push rbp
; X64-NEXT:    mov rbp, rsp
; X64-NEXT:    nop word ptr [rax + rax]
; X64-NEXT:    sub rsp, 0x30
; X64-NEXT:    mov rdi, qword ptr [rdi]
; X64-NEXT:    mov rax, rdi
; X64-NEXT:    add rsp, 0x30
; X64-NEXT:    pop rbp
; X64-NEXT:    ret
;
; ARM64-LABEL: <load_i64>:
; ARM64:         sub sp, sp, #0xa0
; ARM64-NEXT:    stp x29, x30, [sp]
; ARM64-NEXT:    mov x29, sp
; ARM64-NEXT:    nop
; ARM64-NEXT:    ldr x0, [x0]
; ARM64-NEXT:    ldp x29, x30, [sp]
; ARM64-NEXT:    add sp, sp, #0xa0
; ARM64-NEXT:    ret
entry:
  %b = load i64, ptr %a, align 8
  ret i64 %b
}

define i64 @load_i64_alloca() {
; X64-LABEL: <load_i64_alloca>:
; X64:         push rbp
; X64-NEXT:    mov rbp, rsp
; X64-NEXT:    nop word ptr [rax + rax]
; X64-NEXT:    sub rsp, 0x30
; X64-NEXT:    mov rax, qword ptr [rbp - 0x30]
; X64-NEXT:    add rsp, 0x30
; X64-NEXT:    pop rbp
; X64-NEXT:    ret
;
; ARM64-LABEL: <load_i64_alloca>:
; ARM64:         sub sp, sp, #0xb0
; ARM64-NEXT:    stp x29, x30, [sp]
; ARM64-NEXT:    mov x29, sp
; ARM64-NEXT:    nop
; ARM64-NEXT:    ldr x0, [x29, #0xa0]
; ARM64-NEXT:    ldp x29, x30, [sp]
; ARM64-NEXT:    add sp, sp, #0xb0
; ARM64-NEXT:    ret
entry:
   %0 = alloca i64
   %1 = load i64, ptr %0
   ret i64 %1
}

define i64 @load_i64_alt(ptr %a) {
; X64-LABEL: <load_i64_alt>:
; X64:         push rbp
; X64-NEXT:    mov rbp, rsp
; X64-NEXT:    nop word ptr [rax + rax]
; X64-NEXT:    sub rsp, 0x30
; X64-NEXT:    mov rax, qword ptr [rdi]
; X64-NEXT:    mov rdi, qword ptr [rdi]
; X64-NEXT:    mov rax, rdi
; X64-NEXT:    add rsp, 0x30
; X64-NEXT:    pop rbp
; X64-NEXT:    ret
;
; ARM64-LABEL: <load_i64_alt>:
; ARM64:         sub sp, sp, #0xa0
; ARM64-NEXT:    stp x29, x30, [sp]
; ARM64-NEXT:    mov x29, sp
; ARM64-NEXT:    nop
; ARM64-NEXT:    ldr x1, [x0]
; ARM64-NEXT:    ldr x0, [x0]
; ARM64-NEXT:    ldp x29, x30, [sp]
; ARM64-NEXT:    add sp, sp, #0xa0
; ARM64-NEXT:    ret
entry:
  %b = load i64, ptr %a, align 8
  %c = load i64, ptr %a, align 8
  ret i64 %c
}


define i128 @load_i128(ptr %a) {
; X64-LABEL: <load_i128>:
; X64:         push rbp
; X64-NEXT:    mov rbp, rsp
; X64-NEXT:    nop word ptr [rax + rax]
; X64-NEXT:    sub rsp, 0x30
; X64-NEXT:    mov rax, qword ptr [rdi]
; X64-NEXT:    mov rdi, qword ptr [rdi + 0x8]
; X64-NEXT:    mov rdx, rdi
; X64-NEXT:    add rsp, 0x30
; X64-NEXT:    pop rbp
; X64-NEXT:    ret
;
; ARM64-LABEL: <load_i128>:
; ARM64:         sub sp, sp, #0xa0
; ARM64-NEXT:    stp x29, x30, [sp]
; ARM64-NEXT:    mov x29, sp
; ARM64-NEXT:    nop
; ARM64-NEXT:    ldp x0, x1, [x0]
; ARM64-NEXT:    ldp x29, x30, [sp]
; ARM64-NEXT:    add sp, sp, #0xa0
; ARM64-NEXT:    ret
entry:
  %b = load i128, ptr %a, align 8
  ret i128 %b
}

define i128 @load_i128_alloca() {
; X64-LABEL: <load_i128_alloca>:
; X64:         push rbp
; X64-NEXT:    mov rbp, rsp
; X64-NEXT:    nop word ptr [rax + rax]
; X64-NEXT:    sub rsp, 0x40
; X64-NEXT:    mov rax, qword ptr [rbp - 0x40]
; X64-NEXT:    mov rcx, qword ptr [rbp - 0x38]
; X64-NEXT:    mov rdx, rcx
; X64-NEXT:    add rsp, 0x40
; X64-NEXT:    pop rbp
; X64-NEXT:    ret
;
; ARM64-LABEL: <load_i128_alloca>:
; ARM64:         sub sp, sp, #0xb0
; ARM64-NEXT:    stp x29, x30, [sp]
; ARM64-NEXT:    mov x29, sp
; ARM64-NEXT:    nop
; ARM64-NEXT:    add x0, x29, #0xa0
; ARM64-NEXT:    ldp x0, x1, [x0]
; ARM64-NEXT:    ldp x29, x30, [sp]
; ARM64-NEXT:    add sp, sp, #0xb0
; ARM64-NEXT:    ret
entry:
   %0 = alloca i128
   %1 = load i128, ptr %0
   ret i128 %1
}

define i128 @load_i128_alt(ptr %a) {
; X64-LABEL: <load_i128_alt>:
; X64:         push rbp
; X64-NEXT:    mov rbp, rsp
; X64-NEXT:    nop word ptr [rax + rax]
; X64-NEXT:    sub rsp, 0x30
; X64-NEXT:    mov rax, qword ptr [rdi]
; X64-NEXT:    mov rcx, qword ptr [rdi + 0x8]
; X64-NEXT:    mov rax, qword ptr [rdi]
; X64-NEXT:    mov rdi, qword ptr [rdi + 0x8]
; X64-NEXT:    mov rdx, rdi
; X64-NEXT:    add rsp, 0x30
; X64-NEXT:    pop rbp
; X64-NEXT:    ret
;
; ARM64-LABEL: <load_i128_alt>:
; ARM64:         sub sp, sp, #0xa0
; ARM64-NEXT:    stp x29, x30, [sp]
; ARM64-NEXT:    mov x29, sp
; ARM64-NEXT:    nop
; ARM64-NEXT:    ldp x1, x2, [x0]
; ARM64-NEXT:    ldp x0, x1, [x0]
; ARM64-NEXT:    ldp x29, x30, [sp]
; ARM64-NEXT:    add sp, sp, #0xa0
; ARM64-NEXT:    ret
entry:
  %b = load i128, ptr %a, align 8
  %c = load i128, ptr %a, align 8
  ret i128 %c
}


define float @load_float(ptr %a) {
; X64-LABEL: <load_float>:
; X64:         push rbp
; X64-NEXT:    mov rbp, rsp
; X64-NEXT:    nop word ptr [rax + rax]
; X64-NEXT:    sub rsp, 0x30
; X64-NEXT:    movss xmm0, dword ptr [rdi]
; X64-NEXT:    add rsp, 0x30
; X64-NEXT:    pop rbp
; X64-NEXT:    ret
;
; ARM64-LABEL: <load_float>:
; ARM64:         sub sp, sp, #0xa0
; ARM64-NEXT:    stp x29, x30, [sp]
; ARM64-NEXT:    mov x29, sp
; ARM64-NEXT:    nop
; ARM64-NEXT:    ldr s0, [x0]
; ARM64-NEXT:    ldp x29, x30, [sp]
; ARM64-NEXT:    add sp, sp, #0xa0
; ARM64-NEXT:    ret
entry:
  %b = load float, ptr %a, align 4
  ret float %b
}

define float @load_float_alloca() {
; X64-LABEL: <load_float_alloca>:
; X64:         push rbp
; X64-NEXT:    mov rbp, rsp
; X64-NEXT:    nop word ptr [rax + rax]
; X64-NEXT:    sub rsp, 0x30
; X64-NEXT:    movss xmm0, dword ptr [rbp - 0x2c]
; X64-NEXT:    add rsp, 0x30
; X64-NEXT:    pop rbp
; X64-NEXT:    ret
;
; ARM64-LABEL: <load_float_alloca>:
; ARM64:         sub sp, sp, #0xb0
; ARM64-NEXT:    stp x29, x30, [sp]
; ARM64-NEXT:    mov x29, sp
; ARM64-NEXT:    nop
; ARM64-NEXT:    ldr s0, [x29, #0xa0]
; ARM64-NEXT:    ldp x29, x30, [sp]
; ARM64-NEXT:    add sp, sp, #0xb0
; ARM64-NEXT:    ret
entry:
   %0 = alloca float
   %1 = load float, ptr %0
   ret float %1
}

define float @load_float_alt(ptr %a) {
; X64-LABEL: <load_float_alt>:
; X64:         push rbp
; X64-NEXT:    mov rbp, rsp
; X64-NEXT:    nop word ptr [rax + rax]
; X64-NEXT:    sub rsp, 0x30
; X64-NEXT:    movss xmm0, dword ptr [rdi]
; X64-NEXT:    movss xmm0, dword ptr [rdi]
; X64-NEXT:    add rsp, 0x30
; X64-NEXT:    pop rbp
; X64-NEXT:    ret
;
; ARM64-LABEL: <load_float_alt>:
; ARM64:         sub sp, sp, #0xa0
; ARM64-NEXT:    stp x29, x30, [sp]
; ARM64-NEXT:    mov x29, sp
; ARM64-NEXT:    nop
; ARM64-NEXT:    ldr s0, [x0]
; ARM64-NEXT:    ldr s0, [x0]
; ARM64-NEXT:    ldp x29, x30, [sp]
; ARM64-NEXT:    add sp, sp, #0xa0
; ARM64-NEXT:    ret
entry:
  %b = load float, ptr %a, align 4
  %c = load float, ptr %a, align 4
  ret float %c
}


define double @load_double(ptr %a) {
; X64-LABEL: <load_double>:
; X64:         push rbp
; X64-NEXT:    mov rbp, rsp
; X64-NEXT:    nop word ptr [rax + rax]
; X64-NEXT:    sub rsp, 0x30
; X64-NEXT:    movsd xmm0, qword ptr [rdi]
; X64-NEXT:    add rsp, 0x30
; X64-NEXT:    pop rbp
; X64-NEXT:    ret
;
; ARM64-LABEL: <load_double>:
; ARM64:         sub sp, sp, #0xa0
; ARM64-NEXT:    stp x29, x30, [sp]
; ARM64-NEXT:    mov x29, sp
; ARM64-NEXT:    nop
; ARM64-NEXT:    ldr d0, [x0]
; ARM64-NEXT:    ldp x29, x30, [sp]
; ARM64-NEXT:    add sp, sp, #0xa0
; ARM64-NEXT:    ret
entry:
  %b = load double, ptr %a, align 8
  ret double %b
}

define double @load_double_alt(ptr %a) {
; X64-LABEL: <load_double_alt>:
; X64:         push rbp
; X64-NEXT:    mov rbp, rsp
; X64-NEXT:    nop word ptr [rax + rax]
; X64-NEXT:    sub rsp, 0x30
; X64-NEXT:    movsd xmm0, qword ptr [rdi]
; X64-NEXT:    movsd xmm0, qword ptr [rdi]
; X64-NEXT:    add rsp, 0x30
; X64-NEXT:    pop rbp
; X64-NEXT:    ret
;
; ARM64-LABEL: <load_double_alt>:
; ARM64:         sub sp, sp, #0xa0
; ARM64-NEXT:    stp x29, x30, [sp]
; ARM64-NEXT:    mov x29, sp
; ARM64-NEXT:    nop
; ARM64-NEXT:    ldr d0, [x0]
; ARM64-NEXT:    ldr d0, [x0]
; ARM64-NEXT:    ldp x29, x30, [sp]
; ARM64-NEXT:    add sp, sp, #0xa0
; ARM64-NEXT:    ret
entry:
  %b = load double, ptr %a, align 8
  %c = load double, ptr %a, align 8
  ret double %c
}


define <4 x float> @load_4f(ptr %a) {
; X64-LABEL: <load_4f>:
; X64:         push rbp
; X64-NEXT:    mov rbp, rsp
; X64-NEXT:    nop word ptr [rax + rax]
; X64-NEXT:    sub rsp, 0x30
; X64-NEXT:    movups xmm0, xmmword ptr [rdi]
; X64-NEXT:    add rsp, 0x30
; X64-NEXT:    pop rbp
; X64-NEXT:    ret
;
; ARM64-LABEL: <load_4f>:
; ARM64:         sub sp, sp, #0xa0
; ARM64-NEXT:    stp x29, x30, [sp]
; ARM64-NEXT:    mov x29, sp
; ARM64-NEXT:    nop
; ARM64-NEXT:    ldr q0, [x0]
; ARM64-NEXT:    ldp x29, x30, [sp]
; ARM64-NEXT:    add sp, sp, #0xa0
; ARM64-NEXT:    ret
entry:
  %b = load <4 x float>, ptr %a, align 8
  ret <4 x float> %b
}

define <4 x float> @load_4f_alt(ptr %a) {
; X64-LABEL: <load_4f_alt>:
; X64:         push rbp
; X64-NEXT:    mov rbp, rsp
; X64-NEXT:    nop word ptr [rax + rax]
; X64-NEXT:    sub rsp, 0x30
; X64-NEXT:    movups xmm0, xmmword ptr [rdi]
; X64-NEXT:    movups xmm0, xmmword ptr [rdi]
; X64-NEXT:    add rsp, 0x30
; X64-NEXT:    pop rbp
; X64-NEXT:    ret
;
; ARM64-LABEL: <load_4f_alt>:
; ARM64:         sub sp, sp, #0xa0
; ARM64-NEXT:    stp x29, x30, [sp]
; ARM64-NEXT:    mov x29, sp
; ARM64-NEXT:    nop
; ARM64-NEXT:    ldr q0, [x0]
; ARM64-NEXT:    ldr q0, [x0]
; ARM64-NEXT:    ldp x29, x30, [sp]
; ARM64-NEXT:    add sp, sp, #0xa0
; ARM64-NEXT:    ret
entry:
  %b = load <4 x float>, ptr %a, align 8
  %c = load <4 x float>, ptr %a, align 8
  ret <4 x float> %c
}


%struct.i8_i1 = type { i8, i1 }
%struct.i8_i8 = type { i8, i8 }
%struct.i8_i16 = type { i8, i16 }
%struct.i8_i32 = type { i8, i32 }
%struct.i8_i64 = type { i8, i64 }

%struct.i1_i32 = type { i1, i32 }
%struct.i16_i32 = type { i16, i32 }
%struct.i32_i32 = type { i32, i32 }
%struct.i64_i32 = type { i64, i32 }

%struct.ptr_i32 = type { ptr, i32 }
%struct.i32_ptr = type { i32, ptr }

%struct.f32_ptr = type { float, ptr }
%struct.i128_i1 = type { i128, i1 }

%struct.i32_i32_i32_i32_i32_i32 = type { i32, i32, i32, i32, i32, i32 }

define void @load_struct_i8_i1(ptr %0) {
; X64-LABEL: <load_struct_i8_i1>:
; X64:         push rbp
; X64-NEXT:    mov rbp, rsp
; X64-NEXT:    nop word ptr [rax + rax]
; X64-NEXT:    sub rsp, 0x30
; X64-NEXT:    movzx eax, byte ptr [rdi]
; X64-NEXT:    movzx ecx, byte ptr [rdi + 0x1]
; X64-NEXT:    add rsp, 0x30
; X64-NEXT:    pop rbp
; X64-NEXT:    ret
;
; ARM64-LABEL: <load_struct_i8_i1>:
; ARM64:         sub sp, sp, #0xa0
; ARM64-NEXT:    stp x29, x30, [sp]
; ARM64-NEXT:    mov x29, sp
; ARM64-NEXT:    nop
; ARM64-NEXT:    ldrb w1, [x0]
; ARM64-NEXT:    ldrb w2, [x0, #0x1]
; ARM64-NEXT:    ldp x29, x30, [sp]
; ARM64-NEXT:    add sp, sp, #0xa0
; ARM64-NEXT:    ret
  entry:
; Make sure we are after the prologue
; A64: sub sp, sp
; A64: sub sp, sp
; A64-NOT: ldrb w0
; A64: ldrb [[REG:w[0-9]+]], [x0]
; A64-NOT: ldrb [[REG]]
; A64-NEXT: ldrb {{w[0-9]+}}, [x0, #0x1]
; A64-NEXT: add sp
    %1 = load %struct.i8_i1, ptr %0
    ret void
}

define void @load_struct_i8_i8(ptr %0) {
; X64-LABEL: <load_struct_i8_i8>:
; X64:         push rbp
; X64-NEXT:    mov rbp, rsp
; X64-NEXT:    nop word ptr [rax + rax]
; X64-NEXT:    sub rsp, 0x30
; X64-NEXT:    movzx eax, byte ptr [rdi]
; X64-NEXT:    movzx ecx, byte ptr [rdi + 0x1]
; X64-NEXT:    add rsp, 0x30
; X64-NEXT:    pop rbp
; X64-NEXT:    ret
;
; ARM64-LABEL: <load_struct_i8_i8>:
; ARM64:         sub sp, sp, #0xa0
; ARM64-NEXT:    stp x29, x30, [sp]
; ARM64-NEXT:    mov x29, sp
; ARM64-NEXT:    nop
; ARM64-NEXT:    ldrb w1, [x0]
; ARM64-NEXT:    ldrb w2, [x0, #0x1]
; ARM64-NEXT:    ldp x29, x30, [sp]
; ARM64-NEXT:    add sp, sp, #0xa0
; ARM64-NEXT:    ret
  entry:
; Make sure we are after the prologue
; A64: sub sp, sp
; A64: sub sp, sp
; A64-NOT: ldrb w0
; A64: ldrb [[REG:w[0-9]+]], [x0]
; A64-NOT: ldrb [[REG]]
; A64-NEXT: ldrb {{w[0-9]+}}, [x0, #0x1]
; A64-NEXT: add sp
    %1 = load %struct.i8_i8, ptr %0
    ret void
}

define void @load_struct_i8_i16(ptr %0) {
; X64-LABEL: <load_struct_i8_i16>:
; X64:         push rbp
; X64-NEXT:    mov rbp, rsp
; X64-NEXT:    nop word ptr [rax + rax]
; X64-NEXT:    sub rsp, 0x30
; X64-NEXT:    movzx eax, byte ptr [rdi]
; X64-NEXT:    movzx ecx, word ptr [rdi + 0x2]
; X64-NEXT:    add rsp, 0x30
; X64-NEXT:    pop rbp
; X64-NEXT:    ret
;
; ARM64-LABEL: <load_struct_i8_i16>:
; ARM64:         sub sp, sp, #0xa0
; ARM64-NEXT:    stp x29, x30, [sp]
; ARM64-NEXT:    mov x29, sp
; ARM64-NEXT:    nop
; ARM64-NEXT:    ldrb w1, [x0]
; ARM64-NEXT:    ldrh w2, [x0, #0x2]
; ARM64-NEXT:    ldp x29, x30, [sp]
; ARM64-NEXT:    add sp, sp, #0xa0
; ARM64-NEXT:    ret
  entry:
; Make sure we are after the prologue
; A64: sub sp, sp
; A64: sub sp, sp
; A64-NOT: ldrb w0
; A64: ldrb [[REG:w[0-9]+]], [x0]
; A64-NOT: ldrh [[REG]]
; A64-NEXT: ldrh {{w[0-9]+}}, [x0, #0x2]
; A64-NEXT: add sp
    %1 = load %struct.i8_i16, ptr %0
    ret void
}

define void @load_struct_i8_i32(ptr %0) {
; X64-LABEL: <load_struct_i8_i32>:
; X64:         push rbp
; X64-NEXT:    mov rbp, rsp
; X64-NEXT:    nop word ptr [rax + rax]
; X64-NEXT:    sub rsp, 0x30
; X64-NEXT:    movzx eax, byte ptr [rdi]
; X64-NEXT:    mov ecx, dword ptr [rdi + 0x4]
; X64-NEXT:    add rsp, 0x30
; X64-NEXT:    pop rbp
; X64-NEXT:    ret
;
; ARM64-LABEL: <load_struct_i8_i32>:
; ARM64:         sub sp, sp, #0xa0
; ARM64-NEXT:    stp x29, x30, [sp]
; ARM64-NEXT:    mov x29, sp
; ARM64-NEXT:    nop
; ARM64-NEXT:    ldrb w1, [x0]
; ARM64-NEXT:    ldr w2, [x0, #0x4]
; ARM64-NEXT:    ldp x29, x30, [sp]
; ARM64-NEXT:    add sp, sp, #0xa0
; ARM64-NEXT:    ret
  entry:
; Make sure we are after the prologue
; A64: sub sp, sp
; A64: sub sp, sp
; A64-NOT: ldrb w0
; A64: ldrb [[REG:w[0-9]+]], [x0]
; A64-NOT: ldr [[REG]]
; A64-NEXT: ldr {{w[0-9]+}}, [x0, #0x4]
; A64-NEXT: add sp
    %1 = load %struct.i8_i32, ptr %0
    ret void
}

define void @load_struct_i8_i64(ptr %0) {
; X64-LABEL: <load_struct_i8_i64>:
; X64:         push rbp
; X64-NEXT:    mov rbp, rsp
; X64-NEXT:    nop word ptr [rax + rax]
; X64-NEXT:    sub rsp, 0x30
; X64-NEXT:    movzx eax, byte ptr [rdi]
; X64-NEXT:    mov rcx, qword ptr [rdi + 0x8]
; X64-NEXT:    add rsp, 0x30
; X64-NEXT:    pop rbp
; X64-NEXT:    ret
;
; ARM64-LABEL: <load_struct_i8_i64>:
; ARM64:         sub sp, sp, #0xa0
; ARM64-NEXT:    stp x29, x30, [sp]
; ARM64-NEXT:    mov x29, sp
; ARM64-NEXT:    nop
; ARM64-NEXT:    ldrb w1, [x0]
; ARM64-NEXT:    ldr x2, [x0, #0x8]
; ARM64-NEXT:    ldp x29, x30, [sp]
; ARM64-NEXT:    add sp, sp, #0xa0
; ARM64-NEXT:    ret
  entry:
; Make sure we are after the prologue
; A64: sub sp, sp
; A64: sub sp, sp
; A64-NOT: ldrb w0
; A64: ldrb w[[REG:[0-9]+]], [x0]
; A64-NOT: ldr x[[REG]]
; A64-NEXT: ldr {{x[0-9]+}}, [x0, #0x8]
; A64-NEXT: add sp
    %1 = load %struct.i8_i64, ptr %0
    ret void
}

define void @load_struct_i1_i32(ptr %0) {
; X64-LABEL: <load_struct_i1_i32>:
; X64:         push rbp
; X64-NEXT:    mov rbp, rsp
; X64-NEXT:    nop word ptr [rax + rax]
; X64-NEXT:    sub rsp, 0x30
; X64-NEXT:    movzx eax, byte ptr [rdi]
; X64-NEXT:    mov ecx, dword ptr [rdi + 0x4]
; X64-NEXT:    add rsp, 0x30
; X64-NEXT:    pop rbp
; X64-NEXT:    ret
;
; ARM64-LABEL: <load_struct_i1_i32>:
; ARM64:         sub sp, sp, #0xa0
; ARM64-NEXT:    stp x29, x30, [sp]
; ARM64-NEXT:    mov x29, sp
; ARM64-NEXT:    nop
; ARM64-NEXT:    ldrb w1, [x0]
; ARM64-NEXT:    ldr w2, [x0, #0x4]
; ARM64-NEXT:    ldp x29, x30, [sp]
; ARM64-NEXT:    add sp, sp, #0xa0
; ARM64-NEXT:    ret
  entry:
; Make sure we are after the prologue
; A64: sub sp, sp
; A64: sub sp, sp
; A64-NOT: ldrb w0
; A64: ldrb [[REG:w[0-9]+]], [x0]
; A64-NOT: ldr [[REG]]
; A64-NEXT: ldr {{w[0-9]+}}, [x0, #0x4]
; A64-NEXT: add sp
    %1 = load %struct.i1_i32, ptr %0
    ret void
}

define void @load_struct_i16_i32(ptr %0) {
; X64-LABEL: <load_struct_i16_i32>:
; X64:         push rbp
; X64-NEXT:    mov rbp, rsp
; X64-NEXT:    nop word ptr [rax + rax]
; X64-NEXT:    sub rsp, 0x30
; X64-NEXT:    movzx eax, word ptr [rdi]
; X64-NEXT:    mov ecx, dword ptr [rdi + 0x4]
; X64-NEXT:    add rsp, 0x30
; X64-NEXT:    pop rbp
; X64-NEXT:    ret
;
; ARM64-LABEL: <load_struct_i16_i32>:
; ARM64:         sub sp, sp, #0xa0
; ARM64-NEXT:    stp x29, x30, [sp]
; ARM64-NEXT:    mov x29, sp
; ARM64-NEXT:    nop
; ARM64-NEXT:    ldrh w1, [x0]
; ARM64-NEXT:    ldr w2, [x0, #0x4]
; ARM64-NEXT:    ldp x29, x30, [sp]
; ARM64-NEXT:    add sp, sp, #0xa0
; ARM64-NEXT:    ret
  entry:
; Make sure we are after the prologue
; A64: sub sp, sp
; A64: sub sp, sp
; A64-NOT: ldrh w0
; A64: ldrh [[REG:w[0-9]+]], [x0]
; A64-NOT: ldr [[REG]]
; A64-NEXT: ldr {{w[0-9]+}}, [x0, #0x4]
; A64-NEXT: add sp
    %1 = load %struct.i16_i32, ptr %0
    ret void
}

define void @load_struct_i32_i32(ptr %0) {
; X64-LABEL: <load_struct_i32_i32>:
; X64:         push rbp
; X64-NEXT:    mov rbp, rsp
; X64-NEXT:    nop word ptr [rax + rax]
; X64-NEXT:    sub rsp, 0x30
; X64-NEXT:    mov eax, dword ptr [rdi]
; X64-NEXT:    mov ecx, dword ptr [rdi + 0x4]
; X64-NEXT:    add rsp, 0x30
; X64-NEXT:    pop rbp
; X64-NEXT:    ret
;
; ARM64-LABEL: <load_struct_i32_i32>:
; ARM64:         sub sp, sp, #0xa0
; ARM64-NEXT:    stp x29, x30, [sp]
; ARM64-NEXT:    mov x29, sp
; ARM64-NEXT:    nop
; ARM64-NEXT:    ldr w1, [x0]
; ARM64-NEXT:    ldr w2, [x0, #0x4]
; ARM64-NEXT:    ldp x29, x30, [sp]
; ARM64-NEXT:    add sp, sp, #0xa0
; ARM64-NEXT:    ret
  entry:
; Make sure we are after the prologue
; A64: sub sp, sp
; A64: sub sp, sp
; A64-NOT: ldr w0
; A64: ldr [[REG:w[0-9]+]], [x0]
; A64-NOT: ldr [[REG]]
; A64-NEXT: ldr {{w[0-9]+}}, [x0, #0x4]
; A64-NEXT: add sp
    %1 = load %struct.i32_i32, ptr %0
    ret void
}

define void @load_struct_i64_i32(ptr %0) {
; X64-LABEL: <load_struct_i64_i32>:
; X64:         push rbp
; X64-NEXT:    mov rbp, rsp
; X64-NEXT:    nop word ptr [rax + rax]
; X64-NEXT:    sub rsp, 0x30
; X64-NEXT:    mov rax, qword ptr [rdi]
; X64-NEXT:    mov ecx, dword ptr [rdi + 0x8]
; X64-NEXT:    add rsp, 0x30
; X64-NEXT:    pop rbp
; X64-NEXT:    ret
;
; ARM64-LABEL: <load_struct_i64_i32>:
; ARM64:         sub sp, sp, #0xa0
; ARM64-NEXT:    stp x29, x30, [sp]
; ARM64-NEXT:    mov x29, sp
; ARM64-NEXT:    nop
; ARM64-NEXT:    ldr x1, [x0]
; ARM64-NEXT:    ldr w2, [x0, #0x8]
; ARM64-NEXT:    ldp x29, x30, [sp]
; ARM64-NEXT:    add sp, sp, #0xa0
; ARM64-NEXT:    ret
  entry:
; Make sure we are after the prologue
; A64: sub sp, sp
; A64: sub sp, sp
; A64-NOT: ldr x0
; A64: ldr x[[REG:[0-9]+]], [x0]
; A64-NOT: ldr w[[REG]]
; A64-NEXT: ldr {{w[0-9]+}}, [x0, #0x8]
; A64-NEXT: add sp
    %1 = load %struct.i64_i32, ptr %0
    ret void
}

define void @load_struct_ptr_i32(ptr %0) {
; X64-LABEL: <load_struct_ptr_i32>:
; X64:         push rbp
; X64-NEXT:    mov rbp, rsp
; X64-NEXT:    nop word ptr [rax + rax]
; X64-NEXT:    sub rsp, 0x30
; X64-NEXT:    mov rax, qword ptr [rdi]
; X64-NEXT:    mov ecx, dword ptr [rdi + 0x8]
; X64-NEXT:    add rsp, 0x30
; X64-NEXT:    pop rbp
; X64-NEXT:    ret
;
; ARM64-LABEL: <load_struct_ptr_i32>:
; ARM64:         sub sp, sp, #0xa0
; ARM64-NEXT:    stp x29, x30, [sp]
; ARM64-NEXT:    mov x29, sp
; ARM64-NEXT:    nop
; ARM64-NEXT:    ldr x1, [x0]
; ARM64-NEXT:    ldr w2, [x0, #0x8]
; ARM64-NEXT:    ldp x29, x30, [sp]
; ARM64-NEXT:    add sp, sp, #0xa0
; ARM64-NEXT:    ret
  entry:
; Make sure we are after the prologue
; A64: sub sp, sp
; A64: sub sp, sp
; A64-NOT: ldr x0
; A64: ldr x[[REG:[0-9]+]], [x0]
; A64-NOT: ldr w[[REG]]
; A64-NEXT: ldr {{w[0-9]+}}, [x0, #0x8]
; A64-NEXT: add sp
    %1 = load %struct.ptr_i32, ptr %0
    ret void
}

define void @load_struct_i32_ptr(ptr %0) {
; X64-LABEL: <load_struct_i32_ptr>:
; X64:         push rbp
; X64-NEXT:    mov rbp, rsp
; X64-NEXT:    nop word ptr [rax + rax]
; X64-NEXT:    sub rsp, 0x30
; X64-NEXT:    mov eax, dword ptr [rdi]
; X64-NEXT:    mov rcx, qword ptr [rdi + 0x8]
; X64-NEXT:    add rsp, 0x30
; X64-NEXT:    pop rbp
; X64-NEXT:    ret
;
; ARM64-LABEL: <load_struct_i32_ptr>:
; ARM64:         sub sp, sp, #0xa0
; ARM64-NEXT:    stp x29, x30, [sp]
; ARM64-NEXT:    mov x29, sp
; ARM64-NEXT:    nop
; ARM64-NEXT:    ldr w1, [x0]
; ARM64-NEXT:    ldr x2, [x0, #0x8]
; ARM64-NEXT:    ldp x29, x30, [sp]
; ARM64-NEXT:    add sp, sp, #0xa0
; ARM64-NEXT:    ret
  entry:
; Make sure we are after the prologue
; A64: sub sp, sp
; A64: sub sp, sp
; A64-NOT: ldr w0
; A64: ldr w[[REG:[0-9]+]], [x0]
; A64-NOT: ldr x[[REG]]
; A64-NEXT: ldr {{x[0-9]+}}, [x0, #0x8]
; A64-NEXT: add sp
    %1 = load %struct.i32_ptr, ptr %0
    ret void
}

define void @load_struct_f32_ptr(ptr %0) {
; X64-LABEL: <load_struct_f32_ptr>:
; X64:         push rbp
; X64-NEXT:    mov rbp, rsp
; X64-NEXT:    nop word ptr [rax + rax]
; X64-NEXT:    sub rsp, 0x30
; X64-NEXT:    movss xmm0, dword ptr [rdi]
; X64-NEXT:    mov rax, qword ptr [rdi + 0x8]
; X64-NEXT:    add rsp, 0x30
; X64-NEXT:    pop rbp
; X64-NEXT:    ret
;
; ARM64-LABEL: <load_struct_f32_ptr>:
; ARM64:         sub sp, sp, #0xa0
; ARM64-NEXT:    stp x29, x30, [sp]
; ARM64-NEXT:    mov x29, sp
; ARM64-NEXT:    nop
; ARM64-NEXT:    ldr s0, [x0]
; ARM64-NEXT:    ldr x1, [x0, #0x8]
; ARM64-NEXT:    ldp x29, x30, [sp]
; ARM64-NEXT:    add sp, sp, #0xa0
; ARM64-NEXT:    ret
  entry:
; Make sure we are after the prologue
; A64: sub sp, sp
; A64: sub sp, sp
; A64-NOT: ldr w0
; A64: ldr w[[REG:[0-9]+]], [x0]
; A64-NOT: ldr x[[REG]]
; A64-NEXT: ldr {{x[0-9]+}}, [x0, #0x8]
; A64-NEXT: add sp
    %1 = load %struct.f32_ptr, ptr %0
    ret void
}

define void @load_struct_i128_i1(ptr %0) {
; X64-LABEL: <load_struct_i128_i1>:
; X64:         push rbp
; X64-NEXT:    mov rbp, rsp
; X64-NEXT:    nop word ptr [rax + rax]
; X64-NEXT:    sub rsp, 0x30
; X64-NEXT:    mov rax, qword ptr [rdi]
; X64-NEXT:    mov rcx, qword ptr [rdi + 0x8]
; X64-NEXT:    movzx edx, byte ptr [rdi + 0x10]
; X64-NEXT:    add rsp, 0x30
; X64-NEXT:    pop rbp
; X64-NEXT:    ret
;
; ARM64-LABEL: <load_struct_i128_i1>:
; ARM64:         sub sp, sp, #0xa0
; ARM64-NEXT:    stp x29, x30, [sp]
; ARM64-NEXT:    mov x29, sp
; ARM64-NEXT:    nop
; ARM64-NEXT:    ldr x1, [x0]
; ARM64-NEXT:    ldr x2, [x0, #0x8]
; ARM64-NEXT:    ldrb w3, [x0, #0x10]
; ARM64-NEXT:    ldp x29, x30, [sp]
; ARM64-NEXT:    add sp, sp, #0xa0
; ARM64-NEXT:    ret
  entry:
; Make sure we are after the prologue
; A64: sub sp, sp
; A64: sub sp, sp
; A64-NOT: ldr w0
; A64: ldr w[[REG:[0-9]+]], [x0]
; A64-NOT: ldr x[[REG]]
; A64-NEXT: ldr {{x[0-9]+}}, [x0, #0x8]
; A64-NEXT: add sp
    %1 = load %struct.i128_i1, ptr %0
    ret void
}

define void @load_struct_i32_i32_i32_i32_i32_i32(ptr %0) {
; X64-LABEL: <load_struct_i32_i32_i32_i32_i32_i32>:
; X64:         push rbp
; X64-NEXT:    mov rbp, rsp
; X64-NEXT:    push rbx
; X64-NEXT:    nop dword ptr [rax + rax]
; X64-NEXT:    sub rsp, 0x28
; X64-NEXT:    mov eax, dword ptr [rdi]
; X64-NEXT:    mov ecx, dword ptr [rdi + 0x4]
; X64-NEXT:    mov edx, dword ptr [rdi + 0x8]
; X64-NEXT:    mov ebx, dword ptr [rdi + 0xc]
; X64-NEXT:    mov esi, dword ptr [rdi + 0x10]
; X64-NEXT:    mov r8d, dword ptr [rdi + 0x14]
; X64-NEXT:    add rsp, 0x28
; X64-NEXT:    pop rbx
; X64-NEXT:    pop rbp
; X64-NEXT:    ret
;
; ARM64-LABEL: <load_struct_i32_i32_i32_i32_i32_i32>:
; ARM64:         sub sp, sp, #0xa0
; ARM64-NEXT:    stp x29, x30, [sp]
; ARM64-NEXT:    mov x29, sp
; ARM64-NEXT:    nop
; ARM64-NEXT:    ldr w1, [x0]
; ARM64-NEXT:    ldr w2, [x0, #0x4]
; ARM64-NEXT:    ldr w3, [x0, #0x8]
; ARM64-NEXT:    ldr w4, [x0, #0xc]
; ARM64-NEXT:    ldr w5, [x0, #0x10]
; ARM64-NEXT:    ldr w6, [x0, #0x14]
; ARM64-NEXT:    ldp x29, x30, [sp]
; ARM64-NEXT:    add sp, sp, #0xa0
; ARM64-NEXT:    ret
  entry:
    %1 = load %struct.i32_i32_i32_i32_i32_i32, ptr %0
    ret void
}
